#-Человек должен инициализироваться именем и фамилией
#- Если ещё не сделали, будет так же полезно уметь сортировать людей! Реализуйте метод `__lt__`, определяющий поведение оператора < (а так же через него оприделяются и <, <=, >= и т.д.). Будем считать что один человек меньше другого если у него ФИО идёт в другом порядке.
#- В человека нужно добавить поле `__id`. Это поле будет итендификатором, который будет отличать двух людей, даже если их ФИО будет совпадать (не забывайте что есть тёски!). Попытайтесь хранить внутри класса Human все уже существующие id в сессии интерпритатора, в конструктор человека добавьте ключевое поле id=None. Если id не передаётся - возьмите любое id еще не занятое (проверить это можно обратившись к информации в классе, которую вы сохраните), и выдайте новому объекту уникальный `__id`. Если поле `__id` уже передано, то если такого id ещё не было у человека - создайте с переданным id, иначе - бросьте ошибку `raise Exceprion("Переданный id уже существует!")`
#- В человека нужно добавить функционал хеширования `__hash__`(будет полезно если мы хотим сделать человека ключем в словаре или положить его в множество), его можно генерировать или из `__id`, или просто из ФИО.

class Human:
    ids = set()
    def __init__(self, name: str, last_name: str, id=None):
        self.name = name
        self.last_name = last_name
        self.__id = id or self.generate_id()
    @classmethod
    def generate_id(cls):
        new_id = 1
        while new_id in cls.ids:
                new_id += 1
        cls.ids.add(new_id)
        return new_id

    def __lt__(self, other):
        return (self.last_name, self.name) < (other.last_name, other.name)

    def __hash__(self):
        return hash((self.name, self.last_name))

    def __repr__(self):
        return f"Человек (Имя = '{self.name}', Фамилия = '{self.last_name}', id={self.__id})"

    def __str__(self):
        return f"{self.name} {self.last_name}"

